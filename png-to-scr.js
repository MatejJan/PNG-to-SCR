// Generated by CoffeeScript 1.10.0
(function() {
  var Converter, addErrorBlock, conversionPaperStrategy, conversionPreserveNeighbors, conversionSingleToInk, converter, status,
    slice = [].slice,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  status = function() {
    var texts;
    texts = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    console.log.apply(console, texts);
    return $('.status').append(texts[0] + "<br/>");
  };

  addErrorBlock = function(x, y, errorClass) {
    return $('.error-blocks').append("<div class=\"error-block " + errorClass + "\" style=\"left: " + (x * 8) + "rem; top: " + (y * 8) + "rem;\"></div>");
  };

  converter = null;

  conversionPaperStrategy = null;

  conversionSingleToInk = false;

  conversionPreserveNeighbors = null;

  $(function() {
    var convert, selectPaperOption, selectPreserveNeighbors, selectSingleToInk;
    console.log("START");
    conversionPaperStrategy = Converter.ConversionStrategy.LighterToPaper;
    conversionPreserveNeighbors = Converter.ConversionStrategy.NeighboursNo;
    $('.file-input').change(function() {
      var extension, file, image, reader;
      $('.status').html('');
      $('.error-blocks').html('');
      $('.downloads').hide();
      $('.downloads .menu').hide();
      file = $('.file-input')[0].files[0];
      console.log("Got file", file);
      console.log("Loading the file ...");
      extension = file.name.substring(_.lastIndexOf(file.name, '.') + 1);
      image = new Image;
      image.onload = function() {
        console.log("Loaded image.");
        $('.image-preview').css({
          width: image.width * 2,
          height: image.height * 2
        });
        status("Analyzing …");
        return converter = new Converter(image, file.name);
      };
      reader = new FileReader();
      reader.addEventListener('load', function() {
        var i, j, results, tapData;
        console.log("Loaded file.");
        switch (extension) {
          case 'png':
            console.log("Setting to image …");
            $('.image-preview').off('load');
            $('.image-preview').on('load', function() {
              return image.src = reader.result;
            });
            return $('.image-preview').attr({
              src: reader.result
            });
          case 'tap':
            console.log("Reading bytes …");
            tapData = new Uint8ClampedArray(reader.result);
            console.log(tapData);
            results = [];
            for (i = j = 0; j <= 50; i = ++j) {
              results.push(console.log(i, String.fromCharCode(tapData[i]), tapData[i]));
            }
            return results;
        }
      });
      switch (extension) {
        case 'png':
          return reader.readAsDataURL(file);
        case 'tap':
          return reader.readAsArrayBuffer(file);
      }
    });
    $('.download-scr').click(function() {
      return converter != null ? converter.downloadScr() : void 0;
    });
    $('.download-tap').click(function() {
      return converter != null ? converter.downloadTap() : void 0;
    });
    $('.conversion-options .option').click(function(event) {
      var $target;
      $target = $(event.target);
      $target.parent().find('.option').removeClass('selected');
      return $target.addClass('selected');
    });
    convert = function() {
      return converter != null ? converter.convertIntoMemory(conversionPaperStrategy, conversionSingleToInk, conversionPreserveNeighbors) : void 0;
    };
    selectPaperOption = function(strategy) {
      conversionPaperStrategy = strategy;
      return convert();
    };
    selectSingleToInk = function(value) {
      conversionSingleToInk = value;
      return convert();
    };
    selectPreserveNeighbors = function(value) {
      conversionPreserveNeighbors = value;
      return convert();
    };
    $('.darker').click(function() {
      return selectPaperOption(Converter.ConversionStrategy.DarkerToPaper);
    });
    $('.lighter').click(function() {
      return selectPaperOption(Converter.ConversionStrategy.LighterToPaper);
    });
    $('.smaller').click(function() {
      return selectPaperOption(Converter.ConversionStrategy.SmallerToPaper);
    });
    $('.bigger').click(function() {
      return selectPaperOption(Converter.ConversionStrategy.BiggerToPaper);
    });
    $('.single-ink').click(function() {
      return selectSingleToInk(true);
    });
    $('.single-paper').click(function() {
      return selectSingleToInk(false);
    });
    $('.neighbor-left').click(function() {
      return selectPreserveNeighbors(Converter.ConversionStrategy.NeighboursLeft);
    });
    $('.neighbor-up').click(function() {
      return selectPreserveNeighbors(Converter.ConversionStrategy.NeighboursUp);
    });
    $('.neighbor-no').click(function() {
      return selectPreserveNeighbors(Converter.ConversionStrategy.NeighboursNo);
    });
    return $('.neighbor-match').click(function() {
      return selectPreserveNeighbors(Converter.ConversionStrategy.NeighboursMatch);
    });
  });

  Converter = (function() {
    Converter.ConversionStrategy = {
      DarkerToPaper: 'DarkerToPaper',
      LighterToPaper: 'LighterToPaper',
      BiggerToPaper: 'BiggerToPaper',
      SmallerToPaper: 'SmallerToPaper',
      NeighboursNo: 'NeighboursNo',
      NeighboursLeft: 'NeighboursLeft',
      NeighboursUp: 'NeighboursUp',
      NeighboursMatch: 'NeighboursMatch'
    };

    function Converter(image1, filename) {
      var canvas, context, i, j, ref, screenCanvas, screenContext;
      this.image = image1;
      this.filename = filename;
      this._processJobQueue = bind(this._processJobQueue, this);
      this.width = this.image.width;
      this.height = this.image.height;
      this.blockWidth = Math.ceil(this.width / 8);
      this.blockHeight = Math.ceil(this.height / 8);
      canvas = $('<canvas>')[0];
      canvas.width = this.width;
      canvas.height = this.height;
      context = canvas.getContext('2d');
      context.drawImage(this.image, 0, 0);
      this.imageData = context.getImageData(0, 0, this.width, this.height);
      screenCanvas = $('.screen')[0];
      screenContext = screenCanvas.getContext('2d');
      this.screenImageData = new ImageData(new Uint8ClampedArray(256 * 192 * 4), 256, 192);
      for (i = j = 0, ref = 256 * 192 * 4; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        this.screenImageData.data[i] = 255;
      }
      this.videoMemory = new Uint8ClampedArray(6912);
      this.updateScreen = (function(_this) {
        return function() {
          return screenContext.putImageData(_this.screenImageData, 0, 0);
        };
      })(this);
      this.updateScreen();
      this.colorThreshold = 128;
      this.brightThreshold = 224;
      this._analyzeBlocks((function(_this) {
        return function() {
          status("All checks completed!");
          $('.current-block').hide();
          if (!_this.error) {
            $('.downloads').show();
            return _this.convertIntoMemory(conversionPaperStrategy, conversionSingleToInk, conversionPreserveNeighbors, function() {
              console.log("Conversion finished.");
              return $('.downloads .menu').show();
            });
          }
        };
      })(this));
    }

    Converter.prototype._analyzeColors = function() {
      var histogram, histogramContext, histogramMax, j, k, len, ref, value;
      histogram = (function() {
        var j, results;
        results = [];
        for (value = j = 0; j <= 255; value = ++j) {
          results.push(0);
        }
        return results;
      })();
      histogramMax = 0;
      ref = this.imageData.data;
      for (j = 0, len = ref.length; j < len; j++) {
        value = ref[j];
        histogram[value]++;
        histogramMax = Math.max(histogramMax, histogram[value]);
      }
      histogramContext = $('.histogram')[0].getContext('2d');
      histogramContext.lineWidth = 1;
      for (value = k = 0; k <= 255; value = ++k) {
        if (value < this.colorThreshold) {
          histogramContext.strokeStyle = "rgb(192,191,0)";
        } else if (value < this.brightThreshold) {
          histogramContext.strokeStyle = "rgb(255,255,0)";
        } else {
          histogramContext.strokeStyle = "rgb(255,255,255)";
        }
        console.log(histogramContext.strokeStyle);
        histogramContext.beginPath();
        histogramContext.moveTo(value + 0.5, 0);
        histogramContext.lineTo(value + 0.5, 16);
        histogramContext.stroke();
        histogramContext.beginPath();
        histogramContext.strokeStyle = "black";
        histogramContext.moveTo(value + 0.5, 16);
        histogramContext.lineTo(value + 0.5, 16 * (1 - Math.pow(histogram[value] / histogramMax, 0.1)));
        histogramContext.stroke();
      }
      return $('.histogram').show();
    };

    Converter.prototype._analyzeBlocks = function(callback) {
      var blockX, blockY, fn, j, jobQueue, k, ref, ref1;
      $('.current-block').show();
      jobQueue = [];
      this.blockData = (function() {
        var j, ref, results;
        results = [];
        for (blockX = j = 0, ref = this.blockWidth; 0 <= ref ? j < ref : j > ref; blockX = 0 <= ref ? ++j : --j) {
          results.push([]);
        }
        return results;
      }).call(this);
      for (blockY = j = 0, ref = this.blockHeight; 0 <= ref ? j < ref : j > ref; blockY = 0 <= ref ? ++j : --j) {
        fn = (function(_this) {
          return function(blockX, blockY) {
            return jobQueue.push(function() {
              var color, colors, l, len, m, n, o, p, pixelX, pixelY, pixels, x, y;
              $('.current-block').css({
                left: blockX * 16,
                top: blockY * 16
              });
              colors = [];
              pixels = (function() {
                var l, results;
                results = [];
                for (x = l = 0; l <= 7; x = ++l) {
                  results.push([]);
                }
                return results;
              })();
              for (x = l = 0; l < 8; x = ++l) {
                for (y = m = 0; m < 8; y = ++m) {
                  pixelX = blockX * 8 + x;
                  pixelY = blockY * 8 + y;
                  color = _this._getPixelColor(pixelX, pixelY);
                  colors.push(color);
                  pixels[x][y] = color;
                }
              }
              colors = _.uniqBy(colors, function(color) {
                return color.color + color.brightness * 8;
              });
              if (colors.length > 2) {
                status("ERROR: " + colors.length + " colors in block " + blockX + ", " + blockY + ".", colors);
                addErrorBlock(blockX, blockY, 'multiple-colors');
                _this.error = true;
              }
              if (colors.length === 2) {
                if (colors[0].brightness !== colors[1].brightness) {
                  if (colors[0].color === 0 || colors[1].color === 0) {
                    colors[0].brightness = 1;
                    colors[1].brightness = 1;
                  } else {
                    status("ERROR: Two levels of brightness in block " + blockX + ", " + blockY + ".", colors);
                    addErrorBlock(blockX, blockY, 'multiple-brightness');
                    _this.error = true;
                  }
                }
              }
              for (n = 0, len = colors.length; n < len; n++) {
                color = colors[n];
                color.pixelCount = 0;
                for (x = o = 0; o < 8; x = ++o) {
                  for (y = p = 0; p < 8; y = ++p) {
                    if (pixels[x][y].color === color.color) {
                      color.pixelCount++;
                    }
                  }
                }
              }
              return _this.blockData[blockX][blockY] = {
                pixels: pixels,
                colors: colors
              };
            });
          };
        })(this);
        for (blockX = k = 0, ref1 = this.blockWidth; 0 <= ref1 ? k < ref1 : k > ref1; blockX = 0 <= ref1 ? ++k : --k) {
          fn(blockX, blockY);
        }
      }
      return this._processJobQueue(jobQueue, callback);
    };

    Converter.prototype.convertIntoMemory = function(conversionPaperStrategy, convertSingleToInk, preserveNeighbors, conversionDoneCallback) {
      var conversionPaperStrategies, obj;
      conversionPaperStrategies = (
        obj = {},
        obj["" + this.constructor.ConversionStrategy.DarkerToPaper] = (function(_this) {
          return function(block) {
            return _this._darkerToPaper(block);
          };
        })(this),
        obj["" + this.constructor.ConversionStrategy.LighterToPaper] = (function(_this) {
          return function(block) {
            return _this._lighterToPaper(block);
          };
        })(this),
        obj["" + this.constructor.ConversionStrategy.SmallerToPaper] = (function(_this) {
          return function(block) {
            return _this._smallerToPaper(block);
          };
        })(this),
        obj["" + this.constructor.ConversionStrategy.BiggerToPaper] = (function(_this) {
          return function(block) {
            return _this._biggerToPaper(block);
          };
        })(this),
        obj
      );
      return this._convertIntoMemory(conversionPaperStrategies[conversionPaperStrategy], convertSingleToInk, preserveNeighbors, conversionDoneCallback);
    };

    Converter.prototype._darkerToPaper = function(block) {
      return this._colorValueComparison(block, (function(_this) {
        return function(darkerColorIndex, lighterColorIndex) {
          return {
            paper: block.colors[darkerColorIndex].color,
            ink: block.colors[lighterColorIndex].color
          };
        };
      })(this));
    };

    Converter.prototype._lighterToPaper = function(block, preserveNeighbors) {
      return this._colorValueComparison(block, (function(_this) {
        return function(darkerColorIndex, lighterColorIndex) {
          return {
            paper: block.colors[lighterColorIndex].color,
            ink: block.colors[darkerColorIndex].color
          };
        };
      })(this));
    };

    Converter.prototype._colorValueComparison = function(block, paperInkCallback) {
      var darkerColorIndex, lighterColorIndex;
      if (block.colors.length === 1) {
        return this._handleSingleValue(block);
      } else {
        darkerColorIndex = block.colors[0].color < block.colors[1].color ? 0 : 1;
        lighterColorIndex = 1 - darkerColorIndex;
        return _.extend(paperInkCallback(darkerColorIndex, lighterColorIndex), {
          brightness: block.colors[0].brightness || block.colors[1].brightness
        });
      }
    };

    Converter.prototype._handleSingleValue = function(block) {
      return {
        paper: block.colors[0].color,
        ink: block.colors[0].color,
        brightness: block.colors[0].brightness
      };
    };

    Converter.prototype._smallerToPaper = function(block) {
      return this._areaComparison(block, (function(_this) {
        return function(smallerColorIndex, biggerColorIndex) {
          return {
            paper: block.colors[smallerColorIndex].color,
            ink: block.colors[biggerColorIndex].color
          };
        };
      })(this));
    };

    Converter.prototype._biggerToPaper = function(block) {
      return this._areaComparison(block, (function(_this) {
        return function(smallerColorIndex, biggerColorIndex) {
          return {
            paper: block.colors[biggerColorIndex].color,
            ink: block.colors[smallerColorIndex].color
          };
        };
      })(this));
    };

    Converter.prototype._areaComparison = function(block, paperInkCallback) {
      var biggerColorIndex, smallerColorIndex;
      if (block.colors.length === 1) {
        return this._handleSingleValue(block);
      } else {
        smallerColorIndex = block.colors[0].pixelCount < 8 * 8 / 2 ? 0 : 1;
        biggerColorIndex = 1 - smallerColorIndex;
        return _.extend(paperInkCallback(smallerColorIndex, biggerColorIndex), {
          brightness: block.colors[0].brightness || block.colors[1].brightness
        });
      }
    };

    Converter.prototype._convertIntoMemory = function(comparisonCallback, convertSingleToInk, preserveNeighbors, conversionDoneCallback) {
      var blockX, blockY, fn, j, jobQueue, k;
      clearTimeout(this._currentJobQueueTimeout);
      jobQueue = [];
      this.attributeData = (function() {
        var j, ref, results;
        results = [];
        for (blockX = j = 0, ref = this.blockWidth; 0 <= ref ? j < ref : j > ref; blockX = 0 <= ref ? ++j : --j) {
          results.push([]);
        }
        return results;
      }).call(this);
      $('.screen-cursor').show();
      for (blockY = j = 0; j < 24; blockY = ++j) {
        fn = (function(_this) {
          return function(blockX, blockY) {
            return jobQueue.push(function() {
              var analyzeNeighbor, analyzeNeighborMatch, attribute, attributeValue, bitIndex, bitValue, blockConvertSingleToInk, blockData, blockRowInThird, i, l, leftMatch, m, n, pixelValue, pixelX, pixelY, previewColor, rowInBlock, rowInVideoMemory, rowValue, thirdIndex, upMatch, x, y;
              $('.screen-cursor').css({
                left: blockX * 16,
                top: blockY * 16
              });
              blockData = _this.blockData[blockX][blockY];
              attribute = comparisonCallback(blockData);
              _this.attributeData[blockX][blockY] = attribute;
              blockConvertSingleToInk = convertSingleToInk;
              if (preserveNeighbors !== _this.constructor.ConversionStrategy.NeighboursNo) {
                analyzeNeighbor = function(neighbourX, neighbourY) {
                  var doSwitch, neighborAttribute, neighborConvertSingleToInk, ref;
                  neighborAttribute = _this.attributeData[neighbourX][neighbourY];
                  neighborConvertSingleToInk = _this.videoMemory[neighbourX + neighbourY * 8 * 32] > 0;
                  if (attribute.paper === attribute.ink) {
                    if (neighborAttribute.paper === neighborAttribute.ink) {
                      if (attribute.ink === neighborAttribute.ink) {
                        return blockConvertSingleToInk = neighborConvertSingleToInk;
                      }
                    } else {
                      return blockConvertSingleToInk = attribute.ink === neighborAttribute.ink;
                    }
                  } else {
                    doSwitch = false;
                    if (neighborAttribute.paper === neighborAttribute.ink) {
                      if (neighborConvertSingleToInk) {
                        if (attribute.paper === neighborAttribute.ink) {
                          doSwitch = true;
                        }
                      } else {
                        if (attribute.ink === neighborAttribute.paper) {
                          doSwitch = true;
                        }
                      }
                    } else {
                      if (attribute.paper === neighborAttribute.ink || attribute.ink === neighborAttribute.paper) {
                        doSwitch = true;
                      }
                    }
                    if (doSwitch) {
                      return ref = [attribute.ink, attribute.paper], attribute.paper = ref[0], attribute.ink = ref[1], ref;
                    }
                  }
                };
                if (preserveNeighbors === _this.constructor.ConversionStrategy.NeighboursLeft) {
                  if (blockY > 0) {
                    analyzeNeighbor(blockX, blockY - 1);
                  }
                  if (blockX > 0) {
                    analyzeNeighbor(blockX - 1, blockY);
                  }
                } else if (preserveNeighbors === _this.constructor.ConversionStrategy.NeighboursUp) {
                  if (blockX > 0) {
                    analyzeNeighbor(blockX - 1, blockY);
                  }
                  if (blockY > 0) {
                    analyzeNeighbor(blockX, blockY - 1);
                  }
                } else {
                  analyzeNeighborMatch = function(neighbourX, neighbourY) {
                    var color, l, len, match, matchedColor, neighborBlockData, ref;
                    neighborBlockData = _this.blockData[neighbourX][neighbourY];
                    match = 0;
                    ref = blockData.colors;
                    for (l = 0, len = ref.length; l < len; l++) {
                      color = ref[l];
                      matchedColor = _.find(neighborBlockData.colors, function(neighbourColor) {
                        return color.color === neighbourColor.color;
                      });
                      if (matchedColor) {
                        match += Math.min(color.pixelCount, matchedColor.pixelCount);
                      }
                    }
                    return match;
                  };
                  leftMatch = blockX > 0 ? analyzeNeighborMatch(blockX - 1, blockY) : 0;
                  upMatch = blockY > 0 ? analyzeNeighborMatch(blockX, blockY - 1) : 0;
                  if (leftMatch > upMatch) {
                    if (blockY > 0) {
                      analyzeNeighbor(blockX, blockY - 1);
                    }
                    if (blockX > 0) {
                      analyzeNeighbor(blockX - 1, blockY);
                    }
                  } else {
                    if (blockX > 0) {
                      analyzeNeighbor(blockX - 1, blockY);
                    }
                    if (blockY > 0) {
                      analyzeNeighbor(blockX, blockY - 1);
                    }
                  }
                }
              }
              attributeValue = 0;
              attributeValue += attribute.brightness << 6;
              attributeValue += attribute.paper << 3;
              attributeValue += attribute.ink;
              _this.videoMemory[6144 + blockX + blockY * 32] = attributeValue;
              for (y = l = 0; l < 8; y = ++l) {
                rowValue = 0;
                for (x = m = 0; m < 8; x = ++m) {
                  pixelX = blockX * 8 + x;
                  pixelY = blockY * 8 + y;
                  if (blockData.colors.length === 1) {
                    pixelValue = blockConvertSingleToInk ? 1 : 0;
                  } else {
                    pixelValue = blockData.pixels[x][y].color === attribute.ink ? 1 : 0;
                  }
                  previewColor = (1 - pixelValue) * 255;
                  for (i = n = 0; n <= 2; i = ++n) {
                    _this.screenImageData.data[(pixelX + pixelY * 256) * 4 + i] = previewColor;
                  }
                  bitIndex = 7 - x;
                  bitValue = 1 << bitIndex;
                  rowValue += bitValue * pixelValue;
                }
                thirdIndex = Math.floor((blockY * 8 + y) / 64);
                blockRowInThird = blockY % 8;
                rowInBlock = y % 8;
                rowInVideoMemory = thirdIndex * 64 + rowInBlock * 8 + blockRowInThird;
                _this.videoMemory[blockX + rowInVideoMemory * 32] = rowValue;
              }
              return _this.updateScreen();
            });
          };
        })(this);
        for (blockX = k = 0; k < 32; blockX = ++k) {
          fn(blockX, blockY);
        }
      }
      return this._processJobQueue(jobQueue, (function(_this) {
        return function() {
          $('.screen-cursor').hide();
          return typeof conversionDoneCallback === "function" ? conversionDoneCallback() : void 0;
        };
      })(this));
    };

    Converter.prototype.downloadScr = function() {
      return this._download([this.videoMemory], 'scr');
    };

    Converter.prototype.downloadTap = function() {
      var blockName, end, index, j, ref, ref1, start;
      start = new Uint8ClampedArray(24);
      ref = this._int16to2x8(19), start[0] = ref[0], start[1] = ref[1];
      start[2] = 0;
      start[3] = 3;
      blockName = this.filename.replace('.png', '');
      for (index = j = 0; j <= 9; index = ++j) {
        start[4 + index] = blockName.charCodeAt(index) || 32;
      }
      start[14] = 0;
      start[15] = 27;
      start[16] = 0;
      start[17] = 64;
      start[18] = 0;
      start[19] = 128;
      start[20] = this._checksum(start, 2, 19);
      ref1 = this._int16to2x8(this.videoMemory.length + 2), start[21] = ref1[0], start[22] = ref1[1];
      start[23] = 255;
      end = new Uint8ClampedArray(1);
      end[0] = start[23] ^ this._checksum(this.videoMemory);
      console.log("tap", start, this.videoMemory, end);
      return this._download([start, this.videoMemory, end], 'tap');
    };

    Converter.prototype._int16to2x8 = function(integer) {
      var highByte, lowByte;
      lowByte = integer & 0xff;
      highByte = (integer & 0xff00) >> 8;
      return [lowByte, highByte];
    };

    Converter.prototype._checksum = function(array, start, end) {
      var checksum, j, len, ref, value;
      if (start == null) {
        start = 0;
      }
      if (end == null) {
        end = array.length - 1;
      }
      checksum = 0;
      ref = array.slice(start, +end + 1 || 9e9);
      for (j = 0, len = ref.length; j < len; j++) {
        value = ref[j];
        checksum ^= value;
      }
      return checksum;
    };

    Converter.prototype._download = function(binaryArrays, extension) {
      var $anchor, anchor;
      $anchor = $('<a>');
      anchor = $anchor[0];
      anchor.href = window.URL.createObjectURL(new Blob(binaryArrays, {
        type: 'application/octet-stream'
      }));
      anchor.download = this.filename.replace('.png', "." + extension);
      $('body').append(anchor);
      anchor.click();
      return $anchor.remove();
    };

    Converter.prototype._processJobQueue = function(jobQueue, callback) {
      var job;
      if (jobQueue.length) {
        job = jobQueue.shift();
        job();
        return this._currentJobQueueTimeout = setTimeout((function(_this) {
          return function() {
            return _this._processJobQueue(jobQueue, callback);
          };
        })(this), 1);
      } else {
        return typeof callback === "function" ? callback() : void 0;
      }
    };

    Converter.prototype._getPixelColor = function(x, y) {
      var blue, brightBlue, brightGreen, brightRed, brightValues, brightness, color, data, green, red;
      data = this._getPixelData(x, y);
      red = data.r > this.colorThreshold ? 1 : 0;
      green = data.g > this.colorThreshold ? 1 : 0;
      blue = data.b > this.colorThreshold ? 1 : 0;
      brightRed = data.r > this.brightThreshold ? 1 : 0;
      brightGreen = data.g > this.brightThreshold ? 1 : 0;
      brightBlue = data.b > this.brightThreshold ? 1 : 0;
      color = blue + red * 2 + green * 4;
      brightValues = [red + brightRed, green + brightGreen, blue + brightBlue];
      if ((indexOf.call(brightValues, 1) >= 0) && (indexOf.call(brightValues, 2) >= 0)) {
        status("Illegal color in pixel " + x + ", " + y + ".");
        brightness = null;
      } else if ((indexOf.call(brightValues, 2) >= 0)) {
        brightness = 1;
      } else {
        brightness = 0;
      }
      return {
        color: color,
        brightness: brightness
      };
    };

    Converter.prototype._getPixelData = function(x, y) {
      var offset;
      offset = (x + y * this.width) * 4;
      return {
        r: this.imageData.data[offset],
        g: this.imageData.data[offset + 1],
        b: this.imageData.data[offset + 2]
      };
    };

    return Converter;

  })();

}).call(this);

//# sourceMappingURL=png-to-scr.js.map
